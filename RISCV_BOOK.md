# 第二章 RV 32I 基准整数指令集 version 2.0 #

这一章介绍了RV32I基准整数指令集，其中大部分也包含在RV64I指令集变体中


----------

    RV32I的设计目的是能够生成编译目标并支持现代操作系统环境。其指令系统还旨在减少小型项目中所需的硬件资源。 RV32I包含47条指令，尽管一条简单的需要陷入的硬件指令的实现就需要覆盖8条SCALL/SBREAK/CSRR*指令。I类型的指令为NOP，将硬件指令数量减少到38个。RV32I几乎可以模拟任何其他ISA扩展（A扩展除外，它需要额外的硬件支持原子性）。


----------


## 2.1 基于基准整数指令集的程序模型 ##
图2.1显示了基本整数子集的用户可见状态。 有31个通用寄存器x1-x31，它们保存整数值。 寄存器x0硬连线到常数0.没有硬连线子程序返回地址链接寄存器，但标准软件调用约定使用寄存器x1来保存调用时的返回地址。 对于RV32，x寄存器为32位宽，对于RV64，它们为64位宽。 本文档使用术语XLEN来指代x寄存器的当前宽度（以位数为32或64）。
另一个用户可见寄存器PC寄存器用来保存当前指令的地址。
    
----------

    可用的架构寄存器数量会对代码大小，性能和能耗产生很大影响。虽然16个寄存器对于运行编译代码的整数ISA来说可能是足够的，但是使用3地址格式在16位指令中编码具有16个寄存器的完整ISA是不可能的。尽管2地址格式是可能的，但它会增加指令数量并降低效率。我们希望避免使用中间指令大小（例如Xtensa的24位指令）来简化基本硬件实现，并且一旦采用32位指令大小，就可以直接支持32个整数寄存器。大量的整数寄存器也有助于高性能代码的性能，可以广泛使用循环展开，软件流水线和缓存切片。出于这些原因，我们为基本ISA选择了32个整数寄存器的常规大小。动态寄存器的使用倾向于由少数经常访问的寄存器控制，并且可以优化寄存器实现以减少频繁访问的寄存器的访问能量[26]。可选的压缩16位指令格式主要只访问8个寄存器，因此可以提供密集的指令编码，而额外的指令集扩展可以支持更大的寄存器空间（平面或分层），如果需要的话。对于资源受限的嵌入式应用程序，我们定义了RV32E子集，它只有16个寄存器（第3章）。


----------


## 2.2 基本指令格式 ##
在基本ISA中，有四种核心指令格式（R / I / S / U），如图2.2所示。 所有都是固定的32位长度，必须在内存中的四字节边界上对齐。 如果目标地址不是四字节对齐，则在采用的分支或无条件跳转上生成指令地址未对齐的异常。 没有为未采用的条件分支生成指令获取未对齐异常。

RISC-V ISA将源（rs1和rs2）和目标（rd）寄存器保持在所有格式的相同位置，以简化解码。 立即数被打包到指令中最左边的可用位，并已被分配以降低硬件复杂性。 特别是，所有立即数的符号位始终位于指令的第31位来加速符号扩展电路。


----------

    解码寄存器说明符通常是实现的关键，因此选择指令格式是为了将所有寄存器说明符保持在所有格式的相同位置，代价是必须跨格式移动立即位（与RISC-IV 共享的属性） aka.SPUR [14]）。在实践中，大多数立即数要么很小，要么需要所有XLEN位。 我们选择了一个非对称立即数分割（常规指令中的12位加上一个特殊指令加载立即数的高20位），以增加可用于常规指令的操作码空间。 此外，这些立即数都是符号扩展的。 我们没有发现到对一些immediates使用零扩展的好处，并希望尽可能简单地保持ISA。


----------


## 2.3  立即数解码变体指令  ##

基于对立即数的处理，指令格式还有两种变体（SB / UJ），如图2.3所示。 在图2.3中，每个立即数子字段用将要生成的立即数值中的位的位置（imm [x]）标记，而不是通常所做的指令立即数字段中的位的位置。 图2.4显示了每种基本指令格式产生的中间值，并标记为显示哪个指令位（inst [y]）产生立即数值的每个位。

S和SB格式之间的唯一区别是12位立即数字段用于编码SB格式中2的倍数的分支偏移。 中间位（imm [10：1]）和符号位保持在固定位置，而不是将指令编码的所有位在硬件中左移一个硬件，而是S格式的最低位（inst [inst] 7]）以SB格式编码高阶位。
类似地，U和UJ格式之间的唯一区别在于，20位立即数向左移位12位以形成U 立即数，并通过1位移位以形成J 立即数。 选择U和UJ格式中的指令比特的位置以最大化与其他格式的重叠并且彼此最大化。


----------

    符号扩展是对临界值的最关键操作之一（特别是在RV64I中），在RISC-V中，所有立即数的符号位始终保存在指令的第31位，以允许符号扩展与指令解码并行进行。虽然更复杂的实现可能有分支和跳转的单独加法器 因为在各种指令中保持立即位的位置不变，所以不会受益于计算，我们希望降低最简单实现的硬件成本。通过旋转B和J的指令编码中的位而不是使用动态硬件多路复用器将立即数乘以2，我们将指令信号扇出和立即数多路复用成本减少了大约2倍。加扰的立即编码将增加可忽略不计静态或提前编译的时间。对于动态生成指令，存在一些小的额外开销，但最常见的短前向分支具有直接的即时编码。


----------


## 2.4 整数计算指令 ##

### 整数-寄存器立即数计算 ###
 大多数整数计算指令对整数寄存器中保存的XLEN位的值进行操作。整数计算指令使用I型格式编码为寄存器和立即数操作，或者使用R型格式编码为寄存器和寄存器操作。 rd寄存器在两种情况下都保存计算的结果。 没有整数计算指令会导致算术异常。


----------

    我们没有包括对整数算术运算的溢出检查的特殊指令集支持，因为可以使用RISC-V分支廉价地实现许多溢出检查。 对无符号加法的溢出检查在加法后只需要一个附加的分支指令。 类似地，带符号数组边界检查只需要一个分支指令。 对签名添加的溢出检查需要多条指令，具体取决于数据是立即数还是变量数。 我们考虑添加分支来测试它们的有符号寄存器操作数的总和是否会溢出，但最终选择从基本ISA中省略这些。


----------


 - ADDI将符号扩展的12位立即数和rs1相加，保存至rd寄存器。 忽略算术溢出，结果只是结果的低XLEN位。 ADDI rd，rs1,0用于实现MV rd，rs1汇编器伪指令。
 - SLTI（如果小于立即数则设置寄存器的值）将值1置于寄存器rd中，如果寄存器rs1小于符号扩展立即数（两者都被视为有符号数），否则将0写入rd。 
 - SLTIU类似，但将值作为无符号数进行比较（即，立即首先对符号扩展为XLEN位，然后将其视为无符号数）。 注意，如果rs1等于零，则SLTIU rd，rs1,1将rd设置为1，否则将rd设置为0（汇编器伪操作SEQZ rd，rs）。
 - ANDI，ORI，XORI是逻辑运算，在寄存器rs1和符号扩展的12位立即数执行按位AND，OR和XOR，并将结果放在rd中。 注意，XORI rd，rs1，-1执行寄存器rs1的逐位逻辑反转（汇编伪指令NOT rd，rs）。

按常数移位被编码为I类型指令。 要移位的操作数在rs1中，移位量在I-immediate字段的低5位中编码。 右移类型在I-immediate的高位编码。 SLLI是逻辑左移（零被移位到低位）; SRLI是逻辑右移（零被移入高位）; SRAI是算术右移（原始符号位被复制到空出的高位）。

LUI（load upper immediate）用于构建32位常量并使用U型格式。 LUI将U-immediate值放在目标寄存器rd的前20位，用零填充最低12位。 AUIPC（在pc上添加立即数）用于构建与pc相关的地址并使用U型格式。 AUIPC与20位U-immediate形成32位偏移，用零填充最低12位，将该偏移添加到pc，然后将结果放入寄存器rd。


----------

    AUIPC指令支持双指令序列，以便从PC访问任意偏移，用于控制流传输和数据访问。 AUIPC和JALR中的12位立即数的组合可以将控制转移到任何32位PC相对地址，而AUIPC加上常规加载或存储指令中的12位立即偏移可以访问任何32位PC  - 相关数据地址。当前的PC可以通过将U-immediate设置为0来获得。虽然JAL +4指令也可以用于获取PC，但它可能导致更简单的微架构中的管道中断或者在更复杂的微架构中污染BTB结构。
    
    
----------

### 整数-寄存器寄存器计算指令 ###
RV32I定义了几种算术R类型的操作。 所有操作都将rs1和rs2寄存器读作源操作数，并将结果写入寄存器rd。 funct7和funct3字段选择操作类型。

ADD和SUB分别执行加法和减法。 忽略溢出，并将结果的低XLEN位写入目标。 SLT和SLTU分别执行有符号和无符号比较，如果rs1 < rs2则写入1到rd，否则为0。 注意，如果rs2不等于零，则SLTU rd，x0，rs2将rd设置为1，否则将rd设置为零（汇编伪伪运算SNEZ rd，rs）。 AND，OR和XOR执行按位逻辑运算。 SLL，SRL和SRA通过寄存器rs2的低5位中保持的移位量对寄存器rs1中的值执行逻辑左，逻辑右和算术右移。

### NOP 指令  ###
 
除了推进pc之外，NOP指令不会改变任何用户可见状态。 NOP编码为ADDI x0，x0,0。

----------

    NOP可用于将代码段与微架构上重要的地址边界对齐，或为内联代码修改留出空间。 尽管有许多可能的方法来编码NOP，但我们定义了规范的NOP编码，以允许微架构优化以及更可读的反汇编输出。
    
    
----------

## 2.5 控制转移指令 ##
RV32I提供两种类型的控制传输指令：无条件跳转和条件分支。 RV32I中的控制传输指令没有体系结构可见的延迟槽。

### 无条件跳转指令 ###
跳转和链接（JAL）指令使用UJ类型格式，其中J-immediate以2个字节的倍数对有符号偏移进行编码。 偏移是符号扩展并添加到pc以形成跳转目标地址。 因此，跳跃可以达到±1 MiB范围。 JAL将跳转后的指令地址（pc + 4）存储到寄存器rd中。 标准软件调用约定使用x1作为返回地址寄存器。
普通的无条件跳转（汇编器伪操作J）被编码为具有rd = x0的JAL。

间接跳转指令JALR（跳转和链接寄存器）使用I型编码。 通过将12位有符号I-immediate添加到寄存器rs1，然后将结果的最低有效位设置为零来获得目标地址。 跳转后的指令地址（pc + 4）写入寄存器rd。 如果不需要结果，寄存器x0可用作目标。

如果目标地址未与四字节边界对齐，则JAL和JALR指令可能会生成未对齐的指令获取异常。




# 第四章 RV64I 基于整数指令集 version 2.0 #

这一章介绍基于第二章描述的整数RV32I指令集系统的RV64I指令集系统，这里只描述和RV32I不同的地方，因此应该配合着第二章一起阅读

## 4.1 寄存器状态
RV64I 拓展了整数寄存器，支持64位用户地址，(在图2.1中的XLEN=64)

## 4.2 整数计算指令
Additional instruction variants are provided to manipulate 32-bit values in RV64I, indicated by a
‘W’ suffix to the opcode. These “*W” instructions ignore the upper 32 bits of their inputs and
always produce 32-bit signed values, i.e. bits XLEN-1 through 31 are equal. They cause an illegal
instruction exception in RV32I.
